Today we look at some quick examples to give a feel for how hardware-level
(operating system) programming is different from at application level.


### The "As-if" substitution principle.

Bishop Berkeley is the patron saint of computer stuff.  If a tree falls in 
the forest and no one is there to hear it,

   - then it could be stored in a register.
   - or could be skipped.
   - or rendering could be deferred until someone walks.

A famous equivalance example is the Turing test.  

This is a core systems principle.  And weirdly is not really talked about.

   - Over-simplifying: given a program P, if program P_better has the same
     observable behavior ("side-effects") as P does --- i.e., it behaves
     "as if" it was P ---  then we say they are equivalent and, for example,
     we can replace P with P_better.

### How as-if lets the compiler wtf-you.

When you write code, you likely reason about how it behaves by looking
at the source code (loops, variables, function calls, etc).  However,
obviously, hardare can't run C/C++/Rust source directly.  Thus the
compiler translates your source code down to low-level operations that
will behave "as if" it was the original (sort of: only if your program
was well-defined).

As part of this translation, compilers aggressively optimize code by
replacing chunks of it with puportedly faster or smaller equivalants that
behave "as if" they were the original.  The compiler may even delete
the code (dead code removal) if it believes an external observer could
not tell.  A very small set of examples:

   - inlining.
   - common sub-expression elimination
   - redundant read elimination.
   - reorder reads and writes.
   - code hoisting.


The key issue here is what an "observer" is.  Roughly speaking, the C
compiler `gcc` that we will use  assumes that only the code you write
can affect values, and only do so sequentially.

Thus, if we have code that does:

    y = 1                   
    x = 2;


`gcc` can reorder these as:

    x = 2;
    y = 1                   

Or even delete both if it sees no reads of them.

Of course, if there is another thread running concurrently, this thread
most certainly can tell the difference.  

For this class, often you will share values with hardware, and the
order of reads and writes to these locations matters very much.   Thus,
this hardware is both an observer and a mutator of these locations.
Unfortunately, `gcc` has no idea that there is an external agent that
can see or affect these values, and so its optimizations can totally
destroy the intended semantics.

One method to handle this problem is to mark any shared memory location as
`volatile`.  The rough rule for `gcc` is that it will not remove, add,
or reorder loads and stores to volatile locations.

It's easy to forget to add this type qualifier in each place you need it.
Even worse, if you forget, often the code will almost-always work and
only occasionally break.  Tracking down the problem is a nightmare (add a
`printf`?   Problem goes away.  Remove some code?  Same.  Add some code?
Same.)  As a result, for this class we only ever read/write device memory
using special functions `get32` and `put32` (disussed in lab `1-gpio`).

However, looking at code generated by the compiler that is affected by
such issues is a wonderfully illuminating, concrete way to see the gap
between the fake abstraction of a programming language and what the
machine actually runs.

### Examples

For today:
  - look through the `volatile` directory.
  - To get a feel for compiler observation games, look through the 
    `pointer` directory examples.  Each dereference of a pointer is a
      observation --- the compiler can only optimize if it's sure no pointer
      dereference can catch it.
  - To refresh your view of C, look through the `c-traps` directory.

